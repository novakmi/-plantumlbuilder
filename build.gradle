import org.codehaus.groovy.control.CompilerConfiguration

//This is free software licensed under MIT License, see LICENSE file
//(https://bitbucket.org/novakmi/plantumlbuilder/src/LICENSE)

// For running Gradle, add GRADLE_HOME/bin to PATH
// Tip: Use Intellij Idea community edition to work with gradle (GradleGUI plugin)
// run 'gradle tasks' to see available tasks

apply plugin: 'groovy'
apply plugin: 'maven' // to use maven repository
apply plugin: 'idea' // to generate project+module files for Intellij Idea

version = '0.4.4'
sourceCompatibility = '1.6'
def groupId = "org.bitbucket.novakmi"
def installDir = file('./install')

idea {
        module {
                downloadJavadoc = true
        }
}

repositories {
        maven { url "https://jcenter.bintray.com" } //jcenter repo
        mavenCentral() // standard maven repository
}

// Define dependencies
dependencies {
        compile group: 'org.codehaus.groovy', name: 'groovy-all', version: '2.4.1'
        compile group: 'org.bitbucket.novakmi', name: 'nodebuilder', version: '0.9.0'
        // dependencies for tests
        testCompile group: 'net.sourceforge.plantuml', name: 'plantuml', version: '8020'
        testCompile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.9'
        testCompile group: 'org.testng', name: 'testng', version: '6.8.8'
        testCompile group: 'ch.qos.logback', name: 'logback-classic', version: '1.1.2'
        //testCompile 'org.uncommons:reportng:1.1.1'
        testCompile group: 'janino', name: 'janino', version: '2.4.3'
}


jar {
        manifest {
                attributes(
                        'Implementation-Title': project.name,
                        'Implementation-Version': version,
                        'Specification-Vendor': 'Michal Novak (it.novakmi@gmail.com)',
                        'Built-By': 'novakmi',
                        'Specification-Title': project.name,
                        'Extension-Name': project.name,
                        'Specification-Version': version
                )
        }
}

clean << {  //add to clean task
        installDir.deleteDir()
}

task sourcesJar(type: Jar) {
        classifier = 'sources'
        from "${project.projectDir}/src/main"
}

task groovydocJar(type: Jar, dependsOn: groovydoc) {
        classifier = 'groovydoc'
        from groovydoc.destinationDir
}

test {
        useTestNG() {
                suiteXmlBuilder().suite(name: 'Test Plantuml groovy builder') {
                        test(name: 'plantuml', annotations: 'JDK', verbose: '1') {
                                /*
                                    groups {
                                            run {
                                                    include(name: "basic")
                                            }
                                    }
                                 */
                                classes([:]) {
                                        'class'(name: "org.bitbucket.novakmi.test.plantumlbuilder.PlantUmlBuilderTest")
//                                    'class'(name: "org.bitbucket.novakmi.test.plantumlbuilder.PlantUmlBuilderClassPluginTest") {
//                                        methods {
//                                            include(name: "plantPackageTest")
//                                        }
//                                    }
                                        'class'(name: "org.bitbucket.novakmi.test.plantumlbuilder.PlantUmlBuilderSeqPluginTest")
                                        'class'(name: "org.bitbucket.novakmi.test.plantumlbuilder.PlantUmlBuilderClassPluginTest")
                                        'class'(name: "org.bitbucket.novakmi.test.plantumlbuilder.PlantUmlBuilderCompPluginTest")
                                }
                        }
                }
        }
//    options {
        //        listeners << 'org.uncommons.reportng.HTMLReporter'
        //        listeners << 'org.uncommons.reportng.JUnitXMLReporter'
        //    }
}


task prepareInstall(type: Copy, dependsOn: [jar, sourcesJar, groovydocJar]) {
        installDir.mkdirs()
        //logger.quiet("externalJars {}", externalJars)
        from configurations['compile']?.files/*?.findAll { it.absolutePath.indexOf('unspecified') < 0 }*/
        from "${project.projectDir}/build/libs"
        into installDir
}

// zip into build/distributions
task zipInstall(type: Zip, dependsOn: prepareInstall) {
        from installDir.toString()
}

artifacts { // upload also sources and groovydoc
        archives sourcesJar
        archives groovydocJar
}

uploadArchives { // support to upload to github emulated maven repository
        def localMavenDir = System.getenv()['LOCAL_MAVEN_DIR']
        if (!localMavenDir) {
                logger.error("LOCAL_MAVEN_DIR is not defined! Artifacts will not be exported!")
        } else {
                repositories {
                        mavenDeployer {
                                repository(url: "file://localhost/${localMavenDir}/releases")
                                pom.version = version
                                pom.groupId = groupId
                        }
                }
        }
}

// http://daniel.gredler.net/2011/08/08/gradle-keeping-libraries-up-to-date/
// Find any 3rd party libraries which have released new versions
// to the central Maven repository since we last upgraded.
task checkLibVersions << {
        def checked = [:]
        allprojects {
                configurations.each { configuration ->
                        configuration.allDependencies.each { dependency ->
                                def ver = dependency.version
                                if (ver && !ver.contains('SNAPSHOT') && !checked[dependency]) {
                                        def group = dependency.group
                                        def path = group.replace('.', '/')
                                        def name = dependency.name
                                        def url = "http://repo1.maven.org/maven2/$path/$name/maven-metadata.xml"
                                        try {
                                                def metadata = new XmlSlurper().parseText(url.toURL().text)
                                                def versions = metadata.versioning.versions.version.collect {
                                                        it.text()
                                                }
                                                versions.removeAll { it.toLowerCase().contains('alpha') }
                                                versions.removeAll { it.toLowerCase().contains('beta') }
                                                versions.removeAll { it.toLowerCase().contains('rc') }
                                                def newest = versions.max()
                                                if (ver != newest) {
                                                        println "$group:$name $ver -> $newest [$versions]"
                                                }
                                        } catch (FileNotFoundException e) {
                                                logger.debug "Unable to download $url: $e.message"
                                        } catch (org.xml.sax.SAXParseException e) {
                                                logger.debug "Unable to parse $url: $e.message"
                                        }
                                        checked[dependency] = true
                                }
                        }
                }
        }
}

def templateDir = "${project.projectDir}/templates"
def scriptDir = "${templateDir}/scripts"
def scriptDirBasic = "${scriptDir}/basic"
def scriptDirPlugin = "${scriptDir}/plugin"
def projectDir = "${templateDir}/project"


private void runCmdInDir(runCmd, dir) {
        logger.info("Running ${runCmd} in ${dir}")
        def proc = runCmd.execute(null, new File(dir))
        proc.waitFor()
        def ret = proc.exitValue()
        logger.info("${runCmd} return code: ${ret}")
        logger.info(proc.in.text)
        if (proc.exitValue() != 0) {
                logger.error("ERROR running ${runCmd}")
                logger.lifecycle(proc.err.text)
                throw new StopActionException("Failed to process ${runCmd} in directory ${dir}")
        }
}


def runTemplateScript(script, dir) {
        def classPath = sourceSets.main.runtimeClasspath.asPath
        def runCmd = "groovy -cp ${classPath} ${dir}/${script}"
        println runCmd
        runCmdInDir(runCmd, dir)
}

task buildTemplates << {
        ["plantClass", "plantSeq"].each {
                runTemplateScript("${it}.groovy", scriptDirBasic)
        }

        ["plantPluginClass", "plantPluginComplexClass", "plantPluginSeqActivate"].each {
                runTemplateScript("${it}.groovy", scriptDirPlugin)
        }

        runTemplateScript("buildUmls.groovy", projectDir)
}

task cleanTemplates << {
        [scriptDirBasic, scriptDirPlugin, projectDir].each {
                ["png", "txt"].each { e ->
                        def dir = new File(it)
                        dir.eachFileMatch(~".*.${e}") { f ->
                                new File(dir, f.name).delete()
                        }
                }
        }
}
